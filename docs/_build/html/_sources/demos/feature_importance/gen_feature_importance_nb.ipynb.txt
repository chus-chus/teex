{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "ab2a6d80-6e23-412c-bcc6-c1f56cef9fe6",
   "metadata": {},
   "source": [
    "### Generating data with available g.t. feature importance explanations"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e5e0a0f3-5add-40f5-bbe7-16d893155732",
   "metadata": {},
   "source": [
    "We are going to see the available options for data generation with g.t. feature importance explanations."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "988bc51d-0525-4e2b-889c-1cf87104feff",
   "metadata": {},
   "source": [
    "#### 1. Generating artificial data with SenecaFI"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "b3c97207-7ffd-4c5b-8f40-dc08a85539e6",
   "metadata": {},
   "outputs": [],
   "source": [
    "from teex.featureImportance.data import SenecaFI"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c4489092-3754-4dea-8d04-a7d00dd65af1",
   "metadata": {},
   "source": [
    "We are going to explore `SenecaFI`, a method from [Evaluating local explanation methods on ground truth, Riccardo Guidotti, 2021].\n",
    "\n",
    "**note** This method was not originally conceived as a data generation procedure, but rather as a way to generate transparent classifiers (i.e. a classifier with available ground truth explanations). We use that generated classifier and some artificially generated data to return a dataset with observations, labels and ground truth explanations. The dataset generated contains numerical features with a binary classification."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "eb591a2e-2d3f-4abb-b9bd-9a8e55fc520f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# instance the data generator\n",
    "dataGen = SenecaFI(nSamples=100, nFeatures=4, randomState=1)\n",
    "\n",
    "# retrieve the generated observations\n",
    "X, y, exps = dataGen[:]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "4cc8220d-887f-45ad-9331-625e97053e82",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Observation: [ 0.34558419 -0.65128101  1.82843024 -0.59277453] \n",
      "Label: 1 \n",
      "Explanation: [ 1.      1.      0.1897 -0.3012]\n"
     ]
    }
   ],
   "source": [
    "print(f'Observation: {X[0]} \\nLabel: {y[0]} \\nExplanation: {exps[0]}')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2ba43771-6816-4896-bd05-8941f993f3a8",
   "metadata": {},
   "source": [
    "The ground truth FI explanations are scales to the range (-1, 1) by feature. That is, if a feature contains a 1 in a particular observation, that means that it is the observation where that feature is most important in the dataset. Inversely, if an observation contains a -1, it means that the specific feature contributes the most negatively in the dataset.\n",
    "\n",
    "One can specify the number of points to be generated (`nSamples`), the number of features (`nFeatures`), the names of the features (`featureNames`) and the random state (`randomState`)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "77cad508-6ec9-4383-a74c-cb0fd1e03255",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['a', 'b', 'c', 'd']"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dataGen.featureNames  # automatically generated"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c66748d3-6a11-4738-b851-4baf2b7bb4aa",
   "metadata": {},
   "source": [
    "The explanations are generated by first creating a random collection of points. Then, creating a random linear expression and finally evaluating its derivative at the points closest to the original observations. The underlying model can be accessed:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "872bdff5-c944-4485-a282-6e0fa89f1790",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<teex.featureImportance.data.TransparentLinearClassifier at 0x12bfd0be0>"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "model = dataGen.transparentModel\n",
    "model"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c0ccd5ac-63c8-4966-a46c-e5f31c5d4f63",
   "metadata": {},
   "source": [
    "This structure follows the sklearn API (`.fit`, `.predict`, `.predict_proba`) and can be used to test explainer methods, for example. An important method that it contains is the `.explain`, which given an observation, explains the prediction. All of the observations that the object receive must be of shape (nObservations, nFeatures)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "14fd3393-dbb2-461d-bdf0-29911954906c",
   "metadata": {},
   "source": [
    "Compute predictions:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "04aed299-25ff-4385-8a2f-23ae88e4605a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Single observation: [1] \n",
      "Multiple observations: [1 1 1 0 0 1 0 1 0 0]\n"
     ]
    }
   ],
   "source": [
    "print(f'Single observation: {model.predict(X[0].reshape(1, -1))} \\nMultiple observations: {model.predict(X[:10])}')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7c5c7129-8678-487f-a2f8-23a8797a2095",
   "metadata": {},
   "source": [
    "Compute class probabilities:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "0e687f61-2405-4db9-8950-c0313dbacbbb",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Single observation: \n",
      "[[0. 1.]] \n",
      "\n",
      "Multiple observations: \n",
      "[[0.         1.        ]\n",
      " [0.05753863 0.94246137]\n",
      " [0.25390828 0.74609172]\n",
      " [1.         0.        ]\n",
      " [0.80108987 0.19891013]\n",
      " [0.         1.        ]\n",
      " [1.         0.        ]\n",
      " [0.         1.        ]\n",
      " [1.         0.        ]\n",
      " [1.         0.        ]]\n"
     ]
    }
   ],
   "source": [
    "print(f'Single observation: \\n{model.predict_proba(X[0].reshape(1, -1))} \\n\\nMultiple observations: \\n{model.predict_proba(X[:10])}')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8167952d-e053-4307-a1ab-07015d819a91",
   "metadata": {},
   "source": [
    "Compute explanations:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "5497131e-030d-48c9-bf86-84c34e72446f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Single observation: \n",
      "[[1. 1. 1. 1.]] \n",
      "\n",
      "Multiple observations: \n",
      "[[ 1.      1.      1.     -1.    ]\n",
      " [ 1.      1.      0.0879 -0.4518]\n",
      " [ 1.      1.      0.0706 -0.6003]\n",
      " [ 1.      1.      0.2038 -0.237 ]\n",
      " [ 1.      1.      0.1008 -0.7226]\n",
      " [ 1.      1.     -1.      1.    ]\n",
      " [ 1.      1.      0.1038 -0.6127]\n",
      " [ 1.      1.      0.1553 -0.4214]\n",
      " [ 1.      1.      0.1394 -0.7511]\n",
      " [ 1.      1.     -0.3793 -0.749 ]]\n"
     ]
    }
   ],
   "source": [
    "print(f'Single observation: \\n{model.explain(X[0].reshape(1, -1))} \\n\\nMultiple observations: \\n{model.explain(X[:10])}')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b9a7dcdd-7436-4bd2-a124-4626b0b7da9c",
   "metadata": {},
   "source": [
    "Note that the scaler will work with the observations that it is explaining."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3.9.6 ('venv': venv)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.6"
  },
  "vscode": {
   "interpreter": {
    "hash": "651cc90e453f42eda0ea45d6d6ba042f06cc4f4319ec6d63d834a721bbb963ae"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
